<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_03) on Mon May 29 11:19:04 CST 2006 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
File (Java 2 Platform SE 5.0)
</TITLE>

<META NAME="keywords" CONTENT="java.io.File class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="File (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/File.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/Externalizable.html" title="java.io 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/File.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="File.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.io</FONT>
<BR>
类 File</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.io.File</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 中的接口">Serializable</A>, <A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口">Comparable</A>&lt;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&gt;</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>File</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A><DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 中的接口">Serializable</A>, <A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口">Comparable</A>&lt;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&gt;</DL>
</PRE>

<P>
文件和目录路径名的抽象表示形式。

<p> 用户界面和操作系统使用与系统相关的<em>路径名字符串</em> 来命名文件和目录。此类呈现分层路径名的一个抽象的、与系统无关的视图。<em>抽象路径名</em> 有两个组件：

 <ol>
<li> 一个可选的与系统有关的<em>前缀</em> 字符串，比如盘符，<code>&quot;/&quot;</code>&#xA0;表示 UNIX 中的根目录，<code>&quot;\\\\&quot;</code>&#xA0;表示 Microsoft Windows UNC 路径名，以及
<li> 零个或更多字符串<em>名称</em> 的序列。
 </ol>

除了最后一个，抽象路径名中的每个名称代表一个目录；最后一个名称既可以代表目录，也可以代表文件。<em>空的</em> 抽象路径名没有前缀和名称序列。

<p> 路径名字符串与抽象路径名之间的转换与系统有关。将抽象路径名转换为路径名字符串时，每个名称与下一个名称之间由单个默认<em>分隔符字符</em> 隔开。默认名称分隔符由系统属性 <code>file.separator</code> 定义，也可以从此类的公共静态字段 <code><A HREF="../../java/io/File.html#separator"><CODE>separator</CODE></A></code> 和 <code><A HREF="../../java/io/File.html#separatorChar"><CODE>separatorChar</CODE></A></code> 中得到。将路径名字符串转换为抽象路径名时，可以使用默认名称分隔符或者受基础系统支持的其他任何名称分隔符来分隔其中的名称。

<p> 无论是抽象路径名还是字符串路径名，都可以是<em>绝对</em> 路径名或<em>相对</em> 路径名。绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件。相反，相对路径名必须使用来自其他路径名的信息进行解释。默认情况下，<code>java.io</code> 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性 <code>user.dir</code> 指定，通常是 Java 虚拟机的调用目录。

<p> 前缀的概念用于处理 UNIX 平台的根目录，以及 Microsoft Windows 平台上的盘符、根目录和 UNC 路径名，如下所示：

 <ul>

<li> 对于 UNIX 平台，绝对路径名的前缀始终是 <code>&quot;/&quot;</code>。相对路径名没有前缀。表示根目录的绝对路径名的前缀为 <code>&quot;/&quot;</code> 并且没有名称序列。

<li> 对于 Microsoft Windows 平台，包含盘符的路径名的前缀由驱动器名和一个 <code>&quot;:&quot;</code> 组成：如果路径名是绝对路径名，后面可能跟着 <code>&quot;\\&quot;</code>。UNC 路径名的前缀是 <code>&quot;\\\\&quot;</code>；主机名和共享名是名称序列中的前两个名称。没有指定驱动器的相对路径名无前缀。

 </ul>

<p> <code>File</code> 类的实例是不可变的；也就是说，一旦创建，<code>File</code> 对象表示的抽象路径名将永不改变。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../serialized-form.html#java.io.File">序列化表格</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#pathSeparator">pathSeparator</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与系统有关的路径分隔符字符，出于方便考虑，它被表示为一个字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#pathSeparatorChar">pathSeparatorChar</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与系统有关的默认路径分隔符字符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#separator">separator</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与系统有关的默认名称分隔符，出于方便考虑，它被表示为一个字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#separatorChar">separatorChar</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与系统有关的默认名称分隔符。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/io/File.html#File(java.io.File, java.lang.String)">File</A></B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;parent,
     <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 parent 抽象路径名和 child 路径名字符串创建一个新 <code>File</code> 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/io/File.html#File(java.lang.String)">File</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;pathname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将给定路径名字符串转换成抽象路径名来创建一个新 <code>File</code> 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/io/File.html#File(java.lang.String, java.lang.String)">File</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;parent,
     <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 parent 路径名字符串和 child 路径名字符串创建一个新 <code>File</code> 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/io/File.html#File(java.net.URI)">File</A></B>(<A HREF="../../java/net/URI.html" title="java.net 中的类">URI</A>&nbsp;uri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将给定的 <tt>file:</tt> URI 转换成一个抽象路径名来创建一个新的 <tt>File</tt> 实例。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#canRead()">canRead</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试应用程序是否可以读取此抽象路径名表示的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#canWrite()">canWrite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试应用程序是否可以修改此抽象路径名表示的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#compareTo(java.io.File)">compareTo</A></B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;pathname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按字母顺序比较两个抽象路径名。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#createNewFile()">createNewFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#createTempFile(java.lang.String, java.lang.String)">createTempFile</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix,
               <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;suffix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#createTempFile(java.lang.String, java.lang.String, java.io.File)">createTempFile</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix,
               <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;suffix,
               <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;directory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#delete()">delete</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除此抽象路径名表示的文件或目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#deleteOnExit()">deleteOnExit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#equals(java.lang.Object)">equals</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名与给定对象是否相等。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#exists()">exists</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名表示的文件或目录是否存在。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getAbsoluteFile()">getAbsoluteFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回抽象路径名的绝对路径名形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getAbsolutePath()">getAbsolutePath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回抽象路径名的绝对路径名字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getCanonicalFile()">getCanonicalFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的规范形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getCanonicalPath()">getCanonicalPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回抽象路径名的规范路径名字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回由此抽象路径名表示的文件或目录的名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getParent()">getParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getParentFile()">getParentFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的父路径名的抽象路径名，如果此路径名没有指定父目录，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getPath()">getPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此抽象路径名转换为一个路径名字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算此抽象路径名的哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#isAbsolute()">isAbsolute</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名是否为绝对路径名。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#isDirectory()">isDirectory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名表示的文件是否是一个目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#isFile()">isFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名表示的文件是否是一个标准文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#isHidden()">isHidden</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名指定的文件是否是一个隐藏文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#lastModified()">lastModified</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名表示的文件最后一次被修改的时间。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#length()">length</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回由此抽象路径名表示的文件的长度。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#list()">list</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#list(java.io.FilenameFilter)">list</A></B>(<A HREF="../../java/io/FilenameFilter.html" title="java.io 中的接口">FilenameFilter</A>&nbsp;filter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#listFiles()">listFiles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个抽象路径名数组，这些路径名表示此抽象路径名所表示目录中的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#listFiles(java.io.FileFilter)">listFiles</A></B>(<A HREF="../../java/io/FileFilter.html" title="java.io 中的接口">FileFilter</A>&nbsp;filter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#listFiles(java.io.FilenameFilter)">listFiles</A></B>(<A HREF="../../java/io/FilenameFilter.html" title="java.io 中的接口">FilenameFilter</A>&nbsp;filter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#listRoots()">listRoots</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列出可用的文件系统根目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#mkdir()">mkdir</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建此抽象路径名指定的目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#mkdirs()">mkdirs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#renameTo(java.io.File)">renameTo</A></B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;dest)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重新命名此抽象路径名表示的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setLastModified(long)">setLastModified</A></B>(long&nbsp;time)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置由此抽象路径名所指定的文件或目录的最后一次修改时间。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setReadOnly()">setReadOnly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记此抽象路径名指定的文件或目录，以便只可对其进行读操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的路径名字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URI.html" title="java.net 中的类">URI</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#toURI()">toURI</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造一个表示此抽象路径名的 <tt>file:</tt> URI。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#toURL()">toURL</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此抽象路径名转换成一个 <code>file:</code> URL。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="separatorChar"><!-- --></A><H3>
separatorChar</H3>
<PRE>
public static final char <B>separatorChar</B></PRE>
<DL>
<DD>与系统有关的默认名称分隔符。此字段被初始化为包含系统属性 <code>file.separator</code> 的值的第一个字符。在 UNIX 系统上，此字段的值为 <code>'/'</code>；在 Microsoft Windows 系统上，它为 <code>'\\'</code>。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/System.html#getProperty(java.lang.String)"><CODE>System.getProperty(java.lang.String)</CODE></A></DL>
</DL>
<HR>

<A NAME="separator"><!-- --></A><H3>
separator</H3>
<PRE>
public static final <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>separator</B></PRE>
<DL>
<DD>与系统有关的默认名称分隔符，出于方便考虑，它被表示为一个字符串。此字符串只包含一个字符，即 <code><A HREF="../../java/io/File.html#separatorChar"><CODE>separatorChar</CODE></A></code>。
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="pathSeparatorChar"><!-- --></A><H3>
pathSeparatorChar</H3>
<PRE>
public static final char <B>pathSeparatorChar</B></PRE>
<DL>
<DD>与系统有关的默认路径分隔符字符。此字段被初始为包含系统属性 <code>path.separator</code> 的值的第一个字符。此字符用于按照<em>路径列表</em> 给出的文件顺序分隔文件名。在 UNIX 系统上，此字段为 <code>':'</code>；在 Microsoft Windows 系统上，它为 <code>';'</code>。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/System.html#getProperty(java.lang.String)"><CODE>System.getProperty(java.lang.String)</CODE></A></DL>
</DL>
<HR>

<A NAME="pathSeparator"><!-- --></A><H3>
pathSeparator</H3>
<PRE>
public static final <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>pathSeparator</B></PRE>
<DL>
<DD>与系统有关的路径分隔符字符，出于方便考虑，它被表示为一个字符串。此字符串只包含一个字符，即 <code><A HREF="../../java/io/File.html#pathSeparatorChar"><CODE>pathSeparatorChar</CODE></A></code>。
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="File(java.lang.String)"><!-- --></A><H3>
File</H3>
<PRE>
public <B>File</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;pathname)</PRE>
<DL>
<DD>通过将给定路径名字符串转换成抽象路径名来创建一个新 <code>File</code> 实例。如果给定字符串是空字符串，则结果是空的抽象路径名。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>pathname</CODE> - 路径名字符串
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>pathname</code> 参数为 <code>null</code></DL>
</DL>
<HR>

<A NAME="File(java.lang.String, java.lang.String)"><!-- --></A><H3>
File</H3>
<PRE>
public <B>File</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;parent,
            <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;child)</PRE>
<DL>
<DD>根据 parent 路径名字符串和 child 路径名字符串创建一个新 <code>File</code> 实例。

<p> 如果 <code>parent</code> 为 <code>null</code>，则创建一个新的 <code>File</code> 实例，这与调用单参数 <code>File</code> 方法，以给定 <code>child</code> 路径名字符串作为参数的效果一样。

<p> 否则，<code>parent</code> 路径名字符串用于表示目录，而 <code>child</code> 路径名字符串用于表示目录或文件。如果 <code>child</code> 路径名字符串是绝对路径名，则用与系统有关的方式将它转换成一个相对路径名。如果 <code>parent</code> 是空字符串，则新的 <code>File</code> 实例是通过将 <code>child</code> 转换成抽象路径名并根据与系统有关的默认目录来分析结果而创建的。否则，将每个路径名字符串转换成一个抽象路径名，并根据父抽象路径名分析子抽象路径名。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 父路径名字符串<DD><CODE>child</CODE> - 子路径名字符串
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>child</code> 为 <code>null</code></DL>
</DL>
<HR>

<A NAME="File(java.io.File, java.lang.String)"><!-- --></A><H3>
File</H3>
<PRE>
public <B>File</B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;parent,
            <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;child)</PRE>
<DL>
<DD>根据 parent 抽象路径名和 child 路径名字符串创建一个新 <code>File</code> 实例。

<p> 如果 <code>parent</code> 为 <code>null</code>，则创建一个新的 <code>File</code> 实例，这与调用给定 <code>child</code> 路径名字符串的单参数 <code>File</code> 构造方法的效果一样。

<p> 否则，<code>parent</code> 抽象路径名用于表示目录，而 <code>child</code> 路径名字符串用于表示目录或文件。如果 <code>child</code> 路径名字符串是绝对路径名，则用与系统有关的方式将它转换成一个相对路径名。如果 <code>parent</code> 是空抽象路径名，则新的 <code>File</code> 实例是通过将 <code>child</code> 转换成抽象路径名并根据与系统有关的默认目录来分析结果而创建的。否则，将每个路径名字符串转换成一个抽象路径名，并根据父抽象路径名分析子抽象路径名。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 父抽象路径名<DD><CODE>child</CODE> - 子路径名字符串
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>child</code> 为 <code>null</code></DL>
</DL>
<HR>

<A NAME="File(java.net.URI)"><!-- --></A><H3>
File</H3>
<PRE>
public <B>File</B>(<A HREF="../../java/net/URI.html" title="java.net 中的类">URI</A>&nbsp;uri)</PRE>
<DL>
<DD>通过将给定的 <tt>file:</tt> URI 转换成一个抽象路径名来创建一个新的 <tt>File</tt> 实例。

<p> <tt>file:</tt> URI 的具体形式与系统有关，因此，由此构造方法执行的转换也与系统有关。 

<p> 对于某个给定抽象路径名 <i>f</i>，可以保证：

<blockquote><tt>new File(</tt><i>&nbsp;f</i><tt>.<A HREF="../../java/io/File.html#toURI()"><CODE>toURI</CODE></A>()).equals(</tt><i>&nbsp;f</i><tt>.<A HREF="../../java/io/File.html#getAbsoluteFile()"><CODE>getAbsoluteFile</CODE></A>())</tt></blockquote>

只要原始抽象路径名、URI 和新的抽象路径名都是在同一 Java 虚拟机（或者它的不同调用）中创建的。但是，当在某一操作系统上的虚拟机中创建的 <tt>file:</tt> URI 在不同操作系统上的虚拟机中被转换成抽象路径名时，这种关系通常是不成立的。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>uri</CODE> - 一个绝对的分层 URI，由一个等于 <tt>&quot;file&quot;</tt> 的 scheme、非空的 path 组件，以及未定义的 authority、query 和 fragment 组件组成
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>uri</tt> 为 <tt>null</tt>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果参数有关的前提不成立<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#toURI()"><CODE>toURI()</CODE></A>, 
<A HREF="../../java/net/URI.html" title="java.net 中的类"><CODE>URI</CODE></A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getName</B>()</PRE>
<DL>
<DD>返回由此抽象路径名表示的文件或目录的名称。该名称是路径名的名称序列中的最后一个名称。如果路径名的名称序列为空，则返回空字符串。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名表示的文件或目录的名称，如果路径名的名称序列为空，则返回空字符串</DL>
</DD>
</DL>
<HR>

<A NAME="getParent()"><!-- --></A><H3>
getParent</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getParent</B>()</PRE>
<DL>
<DD>返回此抽象路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回 <code>null</code>。

<p> 抽象路径名的<em>父</em> 路径名由路径名的前缀（如果有）以及路径名的名称序列中最后一个名称以外的所有名称组成。如果名称序列为空，那么该路径名没有指定父目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>由此抽象路径名指定的父目录的路径名字符串，如果此路径名没有指定父目录，则返回 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getParentFile()"><!-- --></A><H3>
getParentFile</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>getParentFile</B>()</PRE>
<DL>
<DD>返回此抽象路径名的父路径名的抽象路径名，如果此路径名没有指定父目录，则返回 <code>null</code>。

<p> 抽象路径名的<em>父</em> 路径名由路径名的前缀（如果有）以及路径名的名称序列中最后一个名称以外的所有名称组成。如果名称序列为空，那么该路径名没有指定父目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>由此抽象路径名指定的父目录的抽象路径名，如果此路径名没有指定父目录，则返回 <code>null</code><DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPath()"><!-- --></A><H3>
getPath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getPath</B>()</PRE>
<DL>
<DD>将此抽象路径名转换为一个路径名字符串。所得到的字符串使用<A HREF="../../java/io/File.html#separator"><CODE>默认名称分隔符</CODE></A>来分隔名称序列中的名称。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名的字符串形式</DL>
</DD>
</DL>
<HR>

<A NAME="isAbsolute()"><!-- --></A><H3>
isAbsolute</H3>
<PRE>
public boolean <B>isAbsolute</B>()</PRE>
<DL>
<DD>测试此抽象路径名是否为绝对路径名。绝对路径名的定义与系统有关。在 UNIX 系统上，如果路径名的前缀是 <code>&quot;/&quot;</code>，则该路径名是绝对路径名。在 Microsoft Windows 系统上，如果路径名的前缀是后跟 <code>&quot;\\&quot;</code> 的盘符，或者其前缀是 <code>&quot;\\\\&quot;</code>，则该路径名是绝对路径名。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此抽象路径名是绝对路径名，则返回 <code>true</code>；否则返回 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="getAbsolutePath()"><!-- --></A><H3>
getAbsolutePath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getAbsolutePath</B>()</PRE>
<DL>
<DD>返回抽象路径名的绝对路径名字符串。

<p> 如果此抽象路径名已经是绝对路径名，则返回该路径名字符串，这与 <code><A HREF="../../java/io/File.html#getPath()"><CODE>getPath()</CODE></A></code> 方法一样。如果此抽象路径名是空的抽象路径名，则返回当前用户目录的路径名字符串，该目录由系统属性 <code>user.dir</code> 指定。否则，使用与系统有关的方式分析此路径名。在 UNIX 系统上，通过根据当前用户目录分析某一相对路径名，可使该路径名成为绝对路径名。在 Microsoft Windows 系统上，通过由路径名指定的当前驱动器目录（如果有）来分析某一相对路径名，可使该路径名成为绝对路径名；否则，可以根据当前用户目录来分析它。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>绝对路径名字符串，它与此抽象路径名表示相同的文件或目录的
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果无法访问所需的系统属性值。<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#isAbsolute()"><CODE>isAbsolute()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAbsoluteFile()"><!-- --></A><H3>
getAbsoluteFile</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>getAbsoluteFile</B>()</PRE>
<DL>
<DD>返回抽象路径名的绝对路径名形式。等同于 <code>new&nbsp;File(this.<A HREF="../../java/io/File.html#getAbsolutePath()"><CODE>getAbsolutePath()</CODE></A>())</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示与此抽象路径名相同的文件或目录的绝对抽象路径名
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果无法访问所需的系统属性值。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCanonicalPath()"><!-- --></A><H3>
getCanonicalPath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getCanonicalPath</B>()
                        throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>返回抽象路径名的规范路径名字符串。

<p> 规范路径名是绝对路径名，并且是惟一的。规范路径名的准确定义与系统有关。如有必要，此方法首先将路径名转换成绝对路径名，这与调用 <A HREF="../../java/io/File.html#getAbsolutePath()"><CODE>getAbsolutePath()</CODE></A> 方法的效果一样，然后用与系统相关的方式将它映射到其惟一路径名。这通常涉及到从路径名中移除多余的名称（比如 <tt>&quot;.&quot;</tt> 和 <tt>&quot;..&quot;</tt>）、分析符号连接（对于 UNIX 平台），以及将驱动器名转换成标准大小写形式（对于 Microsoft Windows 平台）。

<p> 表示现有文件或目录的每个路径名都有一个惟一的规范形式。表示非存在文件或目录的每个路径名也有一个惟一的规范形式。非存在文件或目录路径名的规范形式可能不同于创建文件或目录之后同一路径名的规范形式。同样，现有文件或目录路径名的规范形式可能不同于删除文件或目录之后同一路径名的规范形式。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示与此抽象路径名相同的文件或目录的规范路径名字符串
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误（可能是因为构造规范路径名需要进行文件系统查询）
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果无法访问所需的系统属性值，或者存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.io.FileDescriptor)"><CODE>SecurityManager.checkRead(java.io.FileDescriptor)</CODE></A></code> 方法拒绝对该文件进行读取访问<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCanonicalFile()"><!-- --></A><H3>
getCanonicalFile</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>getCanonicalFile</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>返回此抽象路径名的规范形式。等同于 <code>new&nbsp;File(this.<A HREF="../../java/io/File.html#getCanonicalPath()"><CODE>getCanonicalPath()</CODE></A>())</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示与此抽象路径名相同的文件或目录的规范路径名字符串
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误（可能是因为构造规范路径名需要进行文件系统查询）
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果无法访问所需的系统属性值，或者存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.io.FileDescriptor)"><CODE>SecurityManager.checkRead(java.io.FileDescriptor)</CODE></A></code> 方法拒绝对该文件进行读取访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toURL()"><!-- --></A><H3>
toURL</H3>
<PRE>
public <A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A> <B>toURL</B>()
          throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 中的类">MalformedURLException</A></PRE>
<DL>
<DD>将此抽象路径名转换成一个 <code>file:</code> URL。该 URL 的具体形式与系统有关。如果可以确定此抽象路径名表示的文件是一个目录，则得到的 URL 将以斜杠结束。

<p> <b>使用注意事项：</b>此方法不会自动避开 URL 中的非法字符。建议新的代码将抽象路径名转换成一个 URL，实现方式是先通过 <A HREF="../../java/io/File.html#toURI()"><CODE>toURI</CODE></A> 方法将抽象路径名转换成 URI，然后通过 <A HREF="../../java/net/URI.html#toURL()"><CODE>URI.toURL</CODE></A> 方法将该 URI 转换成 URL。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示等效文件 URL 的 URL 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 中的类">MalformedURLException</A></CODE> - 如果无法将路径分析为 URL<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#toURI()"><CODE>toURI()</CODE></A>, 
<A HREF="../../java/net/URI.html" title="java.net 中的类"><CODE>URI</CODE></A>, 
<A HREF="../../java/net/URI.html#toURL()"><CODE>URI.toURL()</CODE></A>, 
<A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE>URL</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="toURI()"><!-- --></A><H3>
toURI</H3>
<PRE>
public <A HREF="../../java/net/URI.html" title="java.net 中的类">URI</A> <B>toURI</B>()</PRE>
<DL>
<DD>构造一个表示此抽象路径名的 <tt>file:</tt> URI。 

<p> 该 URI 的具体形式与系统有关。如果可以确定此抽象路径名表示的文件是一个目录，则得到的 URI 将以斜杠结束。

<p> 对于某个给定抽象路径名 <i>f</i>，可保证：

<blockquote><tt>new <A HREF="../../java/io/File.html#File(java.net.URI)"><CODE>File</CODE></A>(</tt><i>&nbsp;f</i><tt>.toURI()).equals(</tt><i>&nbsp;f</i><tt>.<A HREF="../../java/io/File.html#getAbsoluteFile()"><CODE>getAbsoluteFile</CODE></A>())</tt></blockquote>

只要原始抽象路径名、URI 和新的抽象路径名都是在同一 Java 虚拟机（或者它的不同调用）中创建的。但是，由于抽象路径名与系统有关的特性，当在某一操作系统上的虚拟机中创建的 <tt>file:</tt> URI 在不同操作系统上的虚拟机中被转换成抽象路径名时，这种关系通常是不成立的。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>一个绝对的分层 URI，由一个等于 <tt>&quot;file&quot;</tt> 的 scheme、非空的 path 组件，以及未定义的 authority、query 和 fragment 组件组成<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#File(java.net.URI)"><CODE>File(java.net.URI)</CODE></A>, 
<A HREF="../../java/net/URI.html" title="java.net 中的类"><CODE>URI</CODE></A>, 
<A HREF="../../java/net/URI.html#toURL()"><CODE>URI.toURL()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="canRead()"><!-- --></A><H3>
canRead</H3>
<PRE>
public boolean <B>canRead</B>()</PRE>
<DL>
<DD>测试应用程序是否可以读取此抽象路径名表示的文件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名指定的文件存在<em>且</em> 可由应用程序读取时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读取访问</DL>
</DD>
</DL>
<HR>

<A NAME="canWrite()"><!-- --></A><H3>
canWrite</H3>
<PRE>
public boolean <B>canWrite</B>()</PRE>
<DL>
<DD>测试应用程序是否可以修改此抽象路径名表示的文件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当文件系统实际包含此抽象路径名表示的文件<em>且</em> 允许应用程序对该文件进行写入时，返回 <code>true</code>，否则返回 <code>false</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写入访问</DL>
</DD>
</DL>
<HR>

<A NAME="exists()"><!-- --></A><H3>
exists</H3>
<PRE>
public boolean <B>exists</B>()</PRE>
<DL>
<DD>测试此抽象路径名表示的文件或目录是否存在。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名表示的文件或目录存在时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件或目录进行写入访问</DL>
</DD>
</DL>
<HR>

<A NAME="isDirectory()"><!-- --></A><H3>
isDirectory</H3>
<PRE>
public boolean <B>isDirectory</B>()</PRE>
<DL>
<DD>测试此抽象路径名表示的文件是否是一个目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名表示的文件存在<em>且</em> 是一个目录时，才返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读取访问</DL>
</DD>
</DL>
<HR>

<A NAME="isFile()"><!-- --></A><H3>
isFile</H3>
<PRE>
public boolean <B>isFile</B>()</PRE>
<DL>
<DD>测试此抽象路径名表示的文件是否是一个标准文件。如果该文件不是一个目录，此外还满足其他与系统有关的标准，则该文件是<em>标准</em> 文件。由 Java 应用程序创建的非目录文件一定都是标准文件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名表示的文件存在<em>且</em> 是一个标准文件时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读取访问</DL>
</DD>
</DL>
<HR>

<A NAME="isHidden()"><!-- --></A><H3>
isHidden</H3>
<PRE>
public boolean <B>isHidden</B>()</PRE>
<DL>
<DD>测试此抽象路径名指定的文件是否是一个隐藏文件。<em>隐藏</em> 的具体定义与系统有关。在 UNIX 系统上，如果文件名以句点字符 (<code>'.'</code>) 开头，则认为该文件被隐藏。在 Microsoft Windows 系统上，如果在文件系统中文件被标记为隐藏，则认为该文件被隐藏。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名表示的文件是根据基础平台约定被隐藏时，返回 <code>true</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读取访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lastModified()"><!-- --></A><H3>
lastModified</H3>
<PRE>
public long <B>lastModified</B>()</PRE>
<DL>
<DD>返回此抽象路径名表示的文件最后一次被修改的时间。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示文件最后一次被修改的时间的 <code>long</code> 值，用该时间与历元（1970 年 1 月 1 日，00:00:00 GMT）的时间差来计算此值（以毫秒为单位）。如果该文件不存在，或是发生 I/O 错误，则返回 <code>0L</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读取访问</DL>
</DD>
</DL>
<HR>

<A NAME="length()"><!-- --></A><H3>
length</H3>
<PRE>
public long <B>length</B>()</PRE>
<DL>
<DD>返回由此抽象路径名表示的文件的长度。如果此路径名表示一个目录，则返回值是不确定的。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名表示的文件的长度，以字节为单位，如果文件不存在，则返回 <code>0L</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读取访问</DL>
</DD>
</DL>
<HR>

<A NAME="createNewFile()"><!-- --></A><H3>
createNewFile</H3>
<PRE>
public boolean <B>createNewFile</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件。检查文件是否存在，如果不存在则创建该文件，这是单个操作，对于其他所有可能影响该文件的文件系统活动来说，该操作是原子的。
 <P>
注：此方法<i>不应</i> 用于文件锁定，因为所得到的协议可能无法可靠地工作。应该使用 <A HREF="../../java/nio/channels/FileLock.html" title="java.nio.channels 中的类"><CODE>FileLock</CODE></A> 机制替代。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果指定的文件不存在并成功地创建，则返回 <code>true</code>；如果指定的文件已经存在，则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写入访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete()"><!-- --></A><H3>
delete</H3>
<PRE>
public boolean <B>delete</B>()</PRE>
<DL>
<DD>删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则此目录必须为空才能删除。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当成功删除文件或目录时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkDelete(java.lang.String)"><CODE>SecurityManager.checkDelete(java.lang.String)</CODE></A></code> 方法拒绝对文件进行删除访问</DL>
</DD>
</DL>
<HR>

<A NAME="deleteOnExit()"><!-- --></A><H3>
deleteOnExit</H3>
<PRE>
public void <B>deleteOnExit</B>()</PRE>
<DL>
<DD>在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。仅在虚拟机正常终止时，才会试图执行删除操作，这在 Java Language Specification 中已定义。 

<p> 一旦已经请求执行删除操作，就无法取消该请求。所以应小心使用此方法。

 <P>
注：此方法<i>不应</i> 用于文件锁定，因为所得到的协议可能无法可靠地工作。应该使用 <A HREF="../../java/nio/channels/FileLock.html" title="java.nio.channels 中的类"><CODE>FileLock</CODE></A> 设施替代。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkDelete(java.lang.String)"><CODE>SecurityManager.checkDelete(java.lang.String)</CODE></A></code> 方法拒绝对文件进行删除访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#delete()"><CODE>delete()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="list()"><!-- --></A><H3>
list</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[] <B>list</B>()</PRE>
<DL>
<DD>返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。

<p> 如果此抽象路径名并不表示一个目录，则此方法将返回 <code>null</code>。否则，为目录中的每个文件或目录返回一个字符串数组。表示目录本身及其父目录的名称不包括在结果中。每个字符串是一个文件名，而不是一条完整路径。

<p> 不保证所得数组中的相同字符串将以特定顺序出现，特别是不保证它们按字母顺序出现。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。如果目录为空，则数组也将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读取访问</DL>
</DD>
</DL>
<HR>

<A NAME="list(java.io.FilenameFilter)"><!-- --></A><H3>
list</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[] <B>list</B>(<A HREF="../../java/io/FilenameFilter.html" title="java.io 中的接口">FilenameFilter</A>&nbsp;filter)</PRE>
<DL>
<DD>返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的。此方法的行为与 <code><A HREF="../../java/io/File.html#list()"><CODE>list()</CODE></A></code> 方法相同，除了所返回数组中的字符串必须满足过滤器。如果给定 <code>filter</code> 为 <code>null</code>，则接受所有名称。否则，当且仅当在此抽象路径名和它所表示的目录中的文件名或目录名上调用过滤器的 <code><A HREF="../../java/io/FilenameFilter.html#accept(java.io.File, java.lang.String)"><CODE>FilenameFilter.accept(java.io.File, java.lang.String)</CODE></A></code> 方法返回 <code>true</code> 时，该名称才满足过滤器。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>filter</CODE> - 文件名过滤器
<DT><B>返回：</B><DD>由此抽象路径名所表示的目录中的文件和目录的字符串数组，该字符串被给定 <code>filter</code> 所接受。如果目录为空，或者没有名称被过滤器接受，则该数组将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读取访问</DL>
</DD>
</DL>
<HR>

<A NAME="listFiles()"><!-- --></A><H3>
listFiles</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[] <B>listFiles</B>()</PRE>
<DL>
<DD>返回一个抽象路径名数组，这些路径名表示此抽象路径名所表示目录中的文件。

<p> 如果此抽象路径名并不表示一个目录，则此方法将返回 <code>null</code>。否则，为目录中的每个文件或目录返回一个 <code>File</code> 对象数组。表示目录本身及其父目录的路径名不包括在结果中。得到的每个抽象路径名都是根据此抽象路径名，使用 <code><A HREF="../../java/io/File.html#File(java.io.File, java.lang.String)"><CODE>File(File,&nbsp;String)</CODE></A></code> 构造方法构造。所以，如果此路径名是绝对路径名，则得到的每个路径名都是绝对路径名；如果此路径名是相对路径名，则得到的每个路径名都是相对于同一目录的路径名。

<p> 不保证所得数组中的相同字符串将以特定顺序出现，特别是不保证它们按字母顺序出现。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组。如果目录为空，则数组也将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读取访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="listFiles(java.io.FilenameFilter)"><!-- --></A><H3>
listFiles</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[] <B>listFiles</B>(<A HREF="../../java/io/FilenameFilter.html" title="java.io 中的接口">FilenameFilter</A>&nbsp;filter)</PRE>
<DL>
<DD>返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。此方法的行为与 <code><A HREF="../../java/io/File.html#listFiles()"><CODE>listFiles()</CODE></A></code> 方法相同，除了所返回数组中的路径名必须满足过滤器。如果给定 <code>filter</code> 为 <code>null</code>，则接受所有路径名。否则，当且仅当在此抽象路径名和它所表示的目录中的文件名或目录名上调用过滤器的 <code><A HREF="../../java/io/FilenameFilter.html#accept(java.io.File, java.lang.String)"><CODE>FilenameFilter.accept(java.io.File, java.lang.String)</CODE></A></code> 方法返回 <code>true</code> 时，该路径名才满足过滤器。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>filter</CODE> - 文件名过滤器
<DT><B>返回：</B><DD>表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组。如果目录为空，则数组也将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读取访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="listFiles(java.io.FileFilter)"><!-- --></A><H3>
listFiles</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[] <B>listFiles</B>(<A HREF="../../java/io/FileFilter.html" title="java.io 中的接口">FileFilter</A>&nbsp;filter)</PRE>
<DL>
<DD>返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。此方法的行为与 <code><A HREF="../../java/io/File.html#listFiles()"><CODE>listFiles()</CODE></A></code> 方法相同，除了所返回数组中的路径名必须满足过滤器。如果给定 <code>filter</code> 为 <code>null</code>，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 <code><A HREF="../../java/io/FileFilter.html#accept(java.io.File)"><CODE>FileFilter.accept(java.io.File)</CODE></A></code> 方法返回 <code>true</code> 时，该路径名才满足过滤器。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>filter</CODE> - 文件过滤器
<DT><B>返回：</B><DD>表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组。如果目录为空，则数组也将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读取访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="mkdir()"><!-- --></A><H3>
mkdir</H3>
<PRE>
public boolean <B>mkdir</B>()</PRE>
<DL>
<DD>创建此抽象路径名指定的目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当已创建目录时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法不允许创建指定的目录</DL>
</DD>
</DL>
<HR>

<A NAME="mkdirs()"><!-- --></A><H3>
mkdirs</H3>
<PRE>
public boolean <B>mkdirs</B>()</PRE>
<DL>
<DD>创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。注意，如果此操作失败，可能已成功创建了一些必需的父目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当已创建该目录以及所有必需的父目录时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法不允许验证指定目录和所有必需的父目录是否存在；或者 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法不允许创建指定的目录和所有必需的父目录</DL>
</DD>
</DL>
<HR>

<A NAME="renameTo(java.io.File)"><!-- --></A><H3>
renameTo</H3>
<PRE>
public boolean <B>renameTo</B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;dest)</PRE>
<DL>
<DD>重新命名此抽象路径名表示的文件。
 
<p> 此方法行为的许多方面都是与平台有关的：重命名操作无法将一个文件从一个文件系统移动到另一个文件系统，该操作可能不是原子的，如果已经存在具有目标抽象路径名的文件，则该操作可能无法获得成功。应该始终检查返回值，确保重命名操作成功。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>dest</CODE> - 指定文件的新抽象路径名
<DT><B>返回：</B><DD>当且仅当重命名成功时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对原来的和新的路径名进行写入访问
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果参数 <code>dest</code> 为 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="setLastModified(long)"><!-- --></A><H3>
setLastModified</H3>
<PRE>
public boolean <B>setLastModified</B>(long&nbsp;time)</PRE>
<DL>
<DD>设置由此抽象路径名所指定的文件或目录的最后一次修改时间。

<p> 所有平台都支持将文件修改时间设置为最接近的秒数，但一些平台会提供更精确的值。该参数将被截取，以适应受支持的精度。如果设置操作成功，并且没有在文件上发生其他干扰操作，则下一次调用 <code><A HREF="../../java/io/File.html#lastModified()"><CODE>lastModified()</CODE></A></code> 方法将返回传递给此方法的 <code>time</code> 参数（可能被截取）。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>time</CODE> - 最后一次修改的时间，用该时间与历元（1970 年 1 月 1 日，00:00:00 GMT）的时间差来计算（以毫秒为单位）
<DT><B>返回：</B><DD>当且仅当该操作成功时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果该参数为负
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对指定文件进行写入访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setReadOnly()"><!-- --></A><H3>
setReadOnly</H3>
<PRE>
public boolean <B>setReadOnly</B>()</PRE>
<DL>
<DD>标记此抽象路径名指定的文件或目录，以便只可对其进行读操作。在调用此方法后，可以保证在被删除或被标记为允许写访问之前，文件或目录不会发生更改。是否可以删除某个只读文件或目录则取决于基础系统。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当该操作成功时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对指定文件进行写入访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="listRoots()"><!-- --></A><H3>
listRoots</H3>
<PRE>
public static <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[] <B>listRoots</B>()</PRE>
<DL>
<DD>列出可用的文件系统根目录。

<p> 特定 Java 平台可以支持零个或更多个按层次组织的文件系统。每个文件系统有一个 <code>root</code> 目录，可以从这到达文件系统中的其他所有文件。例如，Windows 平台为每个活动驱动器提供了一个根目录；UNIX 平台只有一个根目录，即 <code>&quot;/&quot;</code>。可用文件系统根目录的设置受各种系统级操作的影响，比如可移动介质的插入和弹出，以及断开或卸载那些物理磁盘或虚拟磁盘。

<p> 此方法返回一个 <code>File</code> 对象数组，这些对象表示可用文件系统根的根目录。可以保证本地机器上物理存在的任何文件的规范路径名都以此方法返回的根目录之一开始。

<p> 位于其他一些机器上的文件的规范路径名是通过远程文件系统协议（比如 SMB 或 NFS）访问的，它们可能以此方法返回的根目录之一开始，也可能不是这样。如果远程文件的路径名在语法上无法与本地文件的路径名进行区分，那么它将以此方法返回的根目录之一开始。例如，此方法将返回表示 Windows 平台上映射为网络驱动器的根目录的 <code>File</code> 对象，而包含 UNC 路径名的 <code>File</code> 对象并不是由此方法返回。

<p> 与此类中的大多数方法不同，此方法不抛出安全性异常。如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对特定根目录进行读取访问，则该目录不会显示在结果中。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示可用的文件系统根目录的 <code>File</code> 对象数组，如果无法确定根目录集，则返回 <code>null</code>。如果没有文件系统根目录，则该数组将为空。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createTempFile(java.lang.String, java.lang.String, java.io.File)"><!-- --></A><H3>
createTempFile</H3>
<PRE>
public static <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>createTempFile</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix,
                                  <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;suffix,
                                  <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;directory)
                           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD><p> 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。如果此方法成功返回，则可以保证：

 <ol>
<li> 由返回的抽象路径名表示的文件在此方法被调用之前不存在，并且
<li> 此方法及其所有变体都不会在再次当前调用虚拟机时返回相同的抽象路径名。
 </ol>

此方法只提供了临时文件的部分功能。要安排自动删除此方法创建的文件，可使用 <code><A HREF="../../java/io/File.html#deleteOnExit()"><CODE>deleteOnExit()</CODE></A></code> 方法。

<p> <code>prefix</code> 参数至少必须是三个字节长。建议前缀使用一个短的、有意义的字符串，比如 <code>&quot;hjb&quot;</code> 或 <code>&quot;mail&quot;</code>。<code>suffix</code> 参数可能是 <code>null</code>，在这种情况下，将使用后缀 <code>&quot;.tmp&quot;</code>。

<p> 要创建新文件，可能首先要调整前缀和后缀，使其满足基础平台的限制。如果前缀太长，则将它截断，但前三个字符将始终保留。如果后缀太长，则将它截断，但如果它以句点字符 (<code>'.'</code>) 开始，则该句点以及它后面跟着的三个字符将始终保留。一旦已经进行了这些调整，则将通过连接前缀、五个或更多个内部生成的字符和后缀生成新文件的名称。

<p> 如果 <code>directory</code> 参数为 <code>null</code>，则使用与系统有关的默认临时文件目录。默认临时文件目录由系统属性 <code>java.io.tmpdir</code> 指定。在 UNIX 系统上，此属性的默认值通常是 <code>&quot;/tmp&quot;</code> 或 <code>&quot;/var/tmp&quot;</code>；在 Microsoft Windows 系统上，该值通常是 <code>&quot;C:\\WINNT\\TEMP&quot;</code>。在调用 Java 虚拟机时，可为此系统属性提供不同的值，但如果其他程序更改了此属性，则不保证这会对此方法使用的临时目录产生任何影响。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>prefix</CODE> - 用于生成文件名的前缀字符串；至少必须是三个字符长<DD><CODE>suffix</CODE> - 用于生成文件名的后缀字符串；可能是 <code>null</code>，在这种情况下，将使用后缀 <code>&quot;.tmp&quot;</code><DD><CODE>directory</CODE> - 将创建的文件所在的目录，如果使用默认临时文件目录，则该参数为 <code>null</code>
<DT><B>返回：</B><DD>表示新创建的空文件的抽象路径名
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>prefix</code> 参数包含少于三个的字符
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果无法创建文件
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法不允许创建文件<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createTempFile(java.lang.String, java.lang.String)"><!-- --></A><H3>
createTempFile</H3>
<PRE>
public static <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>createTempFile</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix,
                                  <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;suffix)
                           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。调用此方法等同于调用 <code><A HREF="../../java/io/File.html#createTempFile(java.lang.String, java.lang.String, java.io.File)"><CODE>createTempFile(prefix,&nbsp;suffix,&nbsp;null)</CODE></A></code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>prefix</CODE> - 用于生成文件名的前缀字符串；至少必须是三个字符长<DD><CODE>suffix</CODE> - 用于生成文件名的后缀字符串；可能是 <code>null</code>，在这种情况下，将使用后缀 <code>&quot;.tmp&quot;</code>
<DT><B>返回：</B><DD>表示新创建的空文件的抽象路径名
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>prefix</code> 参数包含少于三个的字符
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果无法创建文件
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法不允许创建文件<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="compareTo(java.io.File)"><!-- --></A><H3>
compareTo</H3>
<PRE>
public int <B>compareTo</B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;pathname)</PRE>
<DL>
<DD>按字母顺序比较两个抽象路径名。此方法定义的顺序取决于基础系统。在 UNIX 系统上，比较路径名时，字母大小写通常很重要，而在 Microsoft Windows 系统上，这通常不重要。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口">Comparable</A>&lt;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&gt;</CODE> 中的 <CODE><A HREF="../../java/lang/Comparable.html#compareTo(T)">compareTo</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>pathname</CODE> - 将与此抽象路径名进行比较的抽象路径名
<DT><B>返回：</B><DD>如果该参数等于此抽象路径名，则返回零；如果此抽象路径名在字母顺序上小于该参数，则返回小于零的值；如果此抽象路径名在字母顺序上大于该参数，则返回大于零的值<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</PRE>
<DL>
<DD>测试此抽象路径名与给定对象是否相等。当且仅当该参数不是 <code>null</code> 且是一个表示与此抽象路径名相同的文件或目录的抽象路径名时，才返回 <code>true</code>。两个抽象路径名是否相等取决于基础系统。在 UNIX 系统上，比较路径名时，字母大小写通常很重要，而在 Microsoft Windows 系统上，这通常不重要。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要与此抽象路径名进行比较的对象
<DT><B>返回：</B><DD>当且仅当对象相同时，返回 <code>true</code>；否则返回 <code>false</code><DT><B>另请参见：</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A>, 
<A HREF="../../java/util/Hashtable.html" title="java.util 中的类"><CODE>Hashtable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>计算此抽象路径名的哈希码。因为抽象路径名的等同性与系统有关，所以对其哈希码的计算也与系统有关。在 UNIX 系统上，抽象路径名的哈希码等于其路径名字符串和十进制值 <code>1234321</code> 的哈希码的<em>异或</em>。在 Microsoft Windows 系统上，哈希码等于其转换成小写的路径名字符串和十进制值 <code>1234321</code> 的哈希码的<em>异或</em>。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名的哈希码<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A>, 
<A HREF="../../java/util/Hashtable.html" title="java.util 中的类"><CODE>Hashtable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>()</PRE>
<DL>
<DD>返回此抽象路径名的路径名字符串。该字符串就是 <code><A HREF="../../java/io/File.html#getPath()"><CODE>getPath()</CODE></A></code> 方法返回的字符串。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名的字符串形式</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/File.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/Externalizable.html" title="java.io 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/File.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="File.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/j2se/1.5.0/docs/relnotes/devdocs-vs-specs.html">Java 2 SDK SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2004 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/j2se/1.5.0/docs/relnotes/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
