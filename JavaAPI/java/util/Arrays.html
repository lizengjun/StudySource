<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_03) on Mon May 29 11:22:13 CST 2006 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
Arrays (Java 2 Platform SE 5.0)
</TITLE>

<META NAME="keywords" CONTENT="java.util.Arrays class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Arrays (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Arrays.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/ArrayList.html" title="java.util 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/util/BitSet.html" title="java.util 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/Arrays.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Arrays.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util</FONT>
<BR>
类 Arrays</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.util.Arrays</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Arrays</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></DL>
</PRE>

<P>
此类包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂。

<p>除非特别注明，否则如果指定数组引用为 null，则此类中的方法都会抛出 <tt>NullPointerException</tt>。

<p>此类中所含方法的文档都包括对<i>实现</i> 的简短描述。应该将这些描述视为<i>实现注意事项</i>，而不应将它们视为<i>规范</i> 的一部分。实现者应该可以随意替代其他算法，只要遵循规范本身即可。（例如，<tt>sort(Object[])</tt> 使用的算法不必是一个合并排序算法，但它必须是<i>稳定的</i>。）

<p>此类是 <a href="../../../guide/collections/index.html">Java Collections Framework</a> 的成员。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口"><CODE>Comparable</CODE></A>, 
<A HREF="../../java/util/Comparator.html" title="java.util 中的接口"><CODE>Comparator</CODE></A></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 中的接口">List</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#asList(T...)">asList</A></B>(T...&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个受指定数组支持的固定大小的列表。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(byte[], byte)">binarySearch</A></B>(byte[]&nbsp;a,
             byte&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定的 byte 型数组，以获得指定的值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(char[], char)">binarySearch</A></B>(char[]&nbsp;a,
             char&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定的 char 型数组，以获得指定的值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(double[], double)">binarySearch</A></B>(double[]&nbsp;a,
             double&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定的 double 型数组，以获得指定的值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(float[], float)">binarySearch</A></B>(float[]&nbsp;a,
             float&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定的 float 型数组，以获得指定的值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(int[], int)">binarySearch</A></B>(int[]&nbsp;a,
             int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定的 int 型数组，以获得指定的值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(long[], long)">binarySearch</A></B>(long[]&nbsp;a,
             long&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定的 long 型数组，以获得指定的值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(java.lang.Object[], java.lang.Object)">binarySearch</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
             <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定数组，以获得指定对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(short[], short)">binarySearch</A></B>(short[]&nbsp;a,
             short&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定的 short 型数组，以获得指定的值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(T[], T, java.util.Comparator)">binarySearch</A></B>(T[]&nbsp;a,
             T&nbsp;key,
             <A HREF="../../java/util/Comparator.html" title="java.util 中的接口">Comparator</A>&lt;? super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用二进制搜索算法来搜索指定数组，以获得指定对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepEquals(java.lang.Object[], java.lang.Object[])">deepEquals</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a1,
           <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定数组彼此是<i>深层相等</i> 的，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepHashCode(java.lang.Object[])">deepHashCode</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的“深层内容”返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepToString(java.lang.Object[])">deepToString</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组“深层内容”的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(boolean[], boolean[])">equals</A></B>(boolean[]&nbsp;a,
       boolean[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 boolean 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(byte[], byte[])">equals</A></B>(byte[]&nbsp;a,
       byte[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 byte 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(char[], char[])">equals</A></B>(char[]&nbsp;a,
       char[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 char 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(double[], double[])">equals</A></B>(double[]&nbsp;a,
       double[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 double 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(float[], float[])">equals</A></B>(float[]&nbsp;a,
       float[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 float 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(int[], int[])">equals</A></B>(int[]&nbsp;a,
       int[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 int 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(long[], long[])">equals</A></B>(long[]&nbsp;a,
       long[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 long 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(java.lang.Object[], java.lang.Object[])">equals</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
       <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 Objects 数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(short[], short[])">equals</A></B>(short[]&nbsp;a,
       short[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指定的 short 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(boolean[], boolean)">fill</A></B>(boolean[]&nbsp;a,
     boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 boolean 值分配给指定 boolean 型数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(boolean[], int, int, boolean)">fill</A></B>(boolean[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 boolean 值分配给指定 boolean 型数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(byte[], byte)">fill</A></B>(byte[]&nbsp;a,
     byte&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 byte 值分配给指定 byte 节型数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(byte[], int, int, byte)">fill</A></B>(byte[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     byte&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 byte 值分配给指定 byte 型数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(char[], char)">fill</A></B>(char[]&nbsp;a,
     char&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 char 值分配给指定 char 型数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(char[], int, int, char)">fill</A></B>(char[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     char&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 char 值分配给指定 char 型数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(double[], double)">fill</A></B>(double[]&nbsp;a,
     double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 double 值分配给指定 double 型数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(double[], int, int, double)">fill</A></B>(double[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 double 值分配给指定 double 型数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(float[], float)">fill</A></B>(float[]&nbsp;a,
     float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 float 值分配给指定 float 型数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(float[], int, int, float)">fill</A></B>(float[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 float 值分配给指定 float 型数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(int[], int)">fill</A></B>(int[]&nbsp;a,
     int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 int 值分配给指定 int 型数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(int[], int, int, int)">fill</A></B>(int[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(long[], int, int, long)">fill</A></B>(long[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 long 值分配给指定 long 型数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(long[], long)">fill</A></B>(long[]&nbsp;a,
     long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 long 值分配给指定 long 型数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(java.lang.Object[], int, int, java.lang.Object)">fill</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 Object 引用分配给指定 Object 数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(java.lang.Object[], java.lang.Object)">fill</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
     <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 Object 引用分配给指定 Object 数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(short[], int, int, short)">fill</A></B>(short[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     short&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 short 值分配给指定 short 型数组指定范围中的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(short[], short)">fill</A></B>(short[]&nbsp;a,
     short&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的 short 值分配给指定 short 型数组的每个元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(boolean[])">hashCode</A></B>(boolean[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(byte[])">hashCode</A></B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(char[])">hashCode</A></B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(double[])">hashCode</A></B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(float[])">hashCode</A></B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(int[])">hashCode</A></B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(long[])">hashCode</A></B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(java.lang.Object[])">hashCode</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(short[])">hashCode</A></B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于指定数组的内容返回哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(byte[])">sort</A></B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的 byte 型数组按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(byte[], int, int)">sort</A></B>(byte[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定 byte 型数组的指定范围按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(char[])">sort</A></B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的 char 型数组按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(char[], int, int)">sort</A></B>(char[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定 char 型数组的指定范围按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(double[])">sort</A></B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的 double 型数组按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(double[], int, int)">sort</A></B>(double[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定 double 型数组的指定范围按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(float[])">sort</A></B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的 float 型数组按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(float[], int, int)">sort</A></B>(float[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定 float  型数组的指定范围按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(int[])">sort</A></B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的 int 型数组按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(int[], int, int)">sort</A></B>(int[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定 int 型数组的指定范围按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(long[])">sort</A></B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的 long 型数组按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(long[], int, int)">sort</A></B>(long[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定 long 型数组的指定范围按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(java.lang.Object[])">sort</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据元素的<i>自然顺序</i>，对指定对象数组按升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(java.lang.Object[], int, int)">sort</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据元素的<i>自然顺序</i>，对指定对象数组的指定范围按升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(short[])">sort</A></B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的 short 型数组按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(short[], int, int)">sort</A></B>(short[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定 short 型数组的指定范围按数字升序进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(T[], java.util.Comparator)">sort</A></B>(T[]&nbsp;a,
     <A HREF="../../java/util/Comparator.html" title="java.util 中的接口">Comparator</A>&lt;? super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据指定比较器产生的顺序对指定对象数组进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(T[], int, int, java.util.Comparator)">sort</A></B>(T[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     <A HREF="../../java/util/Comparator.html" title="java.util 中的接口">Comparator</A>&lt;? super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据指定比较器产生的顺序对指定对象数组的指定范围进行排序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(boolean[])">toString</A></B>(boolean[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(byte[])">toString</A></B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(char[])">toString</A></B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(double[])">toString</A></B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(float[])">toString</A></B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(int[])">toString</A></B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(long[])">toString</A></B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(java.lang.Object[])">toString</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(short[])">toString</A></B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定数组内容的字符串表示形式。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="sort(long[])"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>对指定的 long 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。</DL>
</DD>
</DL>
<HR>

<A NAME="sort(long[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(long[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>对指定 long 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）

<p>该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="sort(int[])"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>对指定的 int 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。</DL>
</DD>
</DL>
<HR>

<A NAME="sort(int[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(int[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>对指定 int 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）<p>

该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》 Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="sort(short[])"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>对指定的 short 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。</DL>
</DD>
</DL>
<HR>

<A NAME="sort(short[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(short[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>对指定 short 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）<p>

该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="sort(char[])"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>对指定的 char 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。</DL>
</DD>
</DL>
<HR>

<A NAME="sort(char[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(char[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>对指定 char 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）<p>

该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[])"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>对指定的 byte 型数组按数字升序进行排序。该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。</DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(byte[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>对指定 byte 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）<p>

该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="sort(double[])"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>对指定的 double 型数组按数字升序进行排序。
 <p>
虽然 <code>&lt;</code> 关系式对不同数字 <code>-0.0 == 0.0</code> 返回的结果为 <code>true</code>，并且认为 NaN 值既不小于或大于任何浮点值，也不等于任何浮点值，甚至不等于它自身。但 <code>&lt;</code> 关系式不能提供所有浮点值的整体排序。为了允许进行排序，此方法不使用 <code>&lt;</code> 关系式来确定数字升序排序，而是利用 <A HREF="../../java/lang/Double.html#compareTo(java.lang.Double)"><CODE>Double.compareTo(java.lang.Double)</CODE></A> 来完成整体排序。此排序法不同于 <code>&lt;</code> 关系式，其中 <code>-0.0</code> 被认为是小于 <code>0.0</code> 的值，并且 NaN 被认为大于其他任何浮点值。为了进行排序，所有 NaN 值都被认为是等效且相等的。
 <p>
该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》 Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。</DL>
</DD>
</DL>
<HR>

<A NAME="sort(double[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(double[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>对指定 double 型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）
 <p>
虽然 <code>&lt;</code> 关系式对不同数字 <code>-0.0 == 0.0</code> 返回的结果为 <code>true</code>，并且认为 NaN 值既不小于或大于任何浮点值，也不等于任何浮点值，甚至不等于它自身。但 <code>&lt;</code> 关系式不能提供所有浮点值的整体排序。为了允许进行排序，此方法不使用 <code>&lt;</code> 关系式来确定数字升序排序，而是利用 <A HREF="../../java/lang/Double.html#compareTo(java.lang.Double)"><CODE>Double.compareTo(java.lang.Double)</CODE></A> 来完成整体排序。此排序法不同于 <code>&lt;</code> 关系式，其中 <code>-0.0</code> 被认为是小于 <code>0.0</code> 的值，并且 NaN 被认为大于其他任何浮点值。为了进行排序，所有 NaN 值都被认为是等效且相等的。
 <p>
该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="sort(float[])"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>对指定的 float 型数组按数字升序进行排序。
 <p>
虽然 <code>&lt;</code> 关系式对不同数字 <code>-0.0f == 0.0f</code> 返回的结果为 <code>true</code>，并且认为 NaN 值既不小于或大于任何浮点值，也不等于任何浮点值，甚至不等于它自身。但 <code>&lt;</code> 关系式不能提供所有浮点值的整体排序。为了允许进行排序，此方法不使用 <code>&lt;</code> 关系式来确定数字升序排序，而是利用 <A HREF="../../java/lang/Float.html#compareTo(java.lang.Float)"><CODE>Float.compareTo(java.lang.Float)</CODE></A> 来完成整体排序。此排序法不同于 <code>&lt;</code> 关系式，其中 <code>-0.0f</code> 被认为是小于 <code>0.0f</code> 的值，并且 NaN 被认为大于其他任何浮点值。为了进行排序，所有 NaN 值都被认为是等效且相等的。
 <p>
该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》 Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。</DL>
</DD>
</DL>
<HR>

<A NAME="sort(float[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(float[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>对指定 float  型数组的指定范围按数字升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）
 <p>
虽然 <code>&lt;</code> 关系式对不同数字 <code>-0.0f == 0.0f</code> 返回的结果为 <code>true</code>，并且认为 NaN 值既不小于或大于任何浮点值，也不等于任何浮点值，甚至不等于它自身。但 <code>&lt;</code> 关系式不能提供所有浮点值的整体排序。为了允许进行排序，此方法不使用 <code>&lt;</code> 关系式来确定数字升序排序，而是利用 <A HREF="../../java/lang/Float.html#compareTo(java.lang.Float)"><CODE>Float.compareTo(java.lang.Float)</CODE></A> 来完成整体排序。此排序法不同于 <code>&lt;</code> 关系式，其中 <code>-0.0f</code> 被认为是小于 <code>0.0f</code> 的值，并且 NaN 被认为大于其他任何浮点值。为了进行排序，所有 NaN 值都被认为是等效且相等的。
 <p>
该排序算法是一个经过调优的快速排序法，改编自 Jon L. Bentley 和 M. Douglas McIlroy 合著的《Engineering a Sort Function", Software-Practice and Experience》Vol. 23(11) P. 1249-1265 (November 1993)。此算法在许多数据集上提供 n*log(n) 性能，这导致其他快速排序会降低二次型性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object[])"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</PRE>
<DL>
<DD>根据元素的<i>自然顺序</i>，对指定对象数组按升序进行排序。数组中的所有元素都必须实现 <tt>Comparable</tt> 接口。此外，数组中的所有元素都必须是<i>可相互比较的</i>（也就是说，对于数组中的任何 <tt>e1</tt> 和 <tt>e2</tt> 元素而言，<tt>e1.compareTo(e2)</tt> 不得抛出 <tt>ClassCastException</tt>）。<p>

保证此排序是<i>稳定的</i>：不会因调用 sort 方法而对相等的元素进行重新排序。<p>

该排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n*log(n) 性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果数组包含不<i>可相互比较的</i> 的元素（例如，字符串和整数）。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口"><CODE>Comparable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>根据元素的<i>自然顺序</i>，对指定对象数组的指定范围按升序进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）此范围中的所有元素都必须实现 <tt>Comparable</tt> 接口。此外，此范围中的所有元素都必须是<i>可相互比较的</i>（也就是说，对于数组中的任何 <tt>e1</tt> 和 <tt>e2</tt> 元素而言，<tt>e1.compareTo(e2)</tt> 不得抛出 <tt>ClassCastException</tt>）。<p>

保证此排序是<i>稳定的</i>：不会因调用 sort 方法而对相等的元素进行重新排序。<p>

该排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n*log(n) 性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果数组包含不<i>可相互比较的</i> 的元素（例如，字符串和整数）。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口"><CODE>Comparable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object,java.util.Comparator)"><!-- --></A><A NAME="sort(T[], java.util.Comparator)"><!-- --></A><H3>
sort</H3>
<PRE>
public static &lt;T&gt; void <B>sort</B>(T[]&nbsp;a,
                            <A HREF="../../java/util/Comparator.html" title="java.util 中的接口">Comparator</A>&lt;? super T&gt;&nbsp;c)</PRE>
<DL>
<DD>根据指定比较器产生的顺序对指定对象数组进行排序。数组中的所有元素都必须是通过指定比较器<i>可相互比较的</i>（也就是说，对于数组中的任何 <tt>e1</tt> 和 <tt>e2</tt> 元素而言，<tt>c.compare(e1, e2)</tt> 不得抛出 <tt>ClassCastException</tt>）。<p>

保证此排序是<i>稳定的</i>：不会因调用 sort 方法而对相等的元素进行重新排序。<p>

该排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n*log(n) 性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>c</CODE> - 确定数组顺序的比较器。<tt>null</tt> 值指示应该使用元素的<i>自然顺序</i>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果数组包含使用指定的比较器不<i>可相互比较的</i> 的元素。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Comparator.html" title="java.util 中的接口"><CODE>Comparator</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object,int,int,java.util.Comparator)"><!-- --></A><A NAME="sort(T[], int, int, java.util.Comparator)"><!-- --></A><H3>
sort</H3>
<PRE>
public static &lt;T&gt; void <B>sort</B>(T[]&nbsp;a,
                            int&nbsp;fromIndex,
                            int&nbsp;toIndex,
                            <A HREF="../../java/util/Comparator.html" title="java.util 中的接口">Comparator</A>&lt;? super T&gt;&nbsp;c)</PRE>
<DL>
<DD>根据指定比较器产生的顺序对指定对象数组的指定范围进行排序。排序的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则排序范围为空。）此范围内的所有元素都必须是通过指定比较器<i>可相互比较的</i>（也就是说，对于该范围中的任何 <tt>e1</tt> 和 <tt>e2</tt> 元素而言，<tt>c.compare(e1, e2)</tt> 不得抛出 <tt>ClassCastException</tt>）。<p>

保证此排序是<i>稳定的</i>：不会因调用 sort 方法而对相等的元素进行重新排序。<p>

该排序算法是一个经过修改的合并排序算法（其中，如果低子列表中的最高元素小于高子列表中的最低元素，则忽略合并）。此算法提供可保证的 n*log(n) 性能。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要排序的数组。<DD><CODE>fromIndex</CODE> - 要排序的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要排序的最后一个元素的索引（不包括）。<DD><CODE>c</CODE> - 确定数组顺序的比较器。<tt>null</tt> 值指示应该使用元素的<i>自然顺序</i>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果数组包含使用指定的比较器不<i>可相互比较的</i> 的元素。
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt><DT><B>另请参见：</B><DD><A HREF="../../java/util/Comparator.html" title="java.util 中的接口"><CODE>Comparator</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(long[], long)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(long[]&nbsp;a,
                               long&nbsp;key)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定的 long 型数组，以获得指定的值。<strong>必须</strong>在进行此调用之前对数组进行排序（通过上面的 <tt>sort</tt> 方法）。如果没有对数组进行排序，则结果是不明确的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#sort(long[])"><CODE>sort(long[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(int[], int)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(int[]&nbsp;a,
                               int&nbsp;key)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定的 int 型数组，以获得指定的值。<strong>必须</strong>在进行此调用之前对数组进行排序（通过上面的 <tt>sort</tt> 方法）。如果没有对数组进行排序，则结果是不明确的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#sort(int[])"><CODE>sort(int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(short[], short)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(short[]&nbsp;a,
                               short&nbsp;key)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定的 short 型数组，以获得指定的值。<strong>必须</strong>在进行此调用之前对数组进行排序（通过上面的 <tt>sort</tt> 方法）。如果没有对数组进行排序，则结果是不明确的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#sort(short[])"><CODE>sort(short[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(char[], char)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(char[]&nbsp;a,
                               char&nbsp;key)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定的 char 型数组，以获得指定的值。<strong>必须</strong>在进行此调用之前对数组进行排序（通过上面的 <tt>sort</tt> 方法）。如果没有对数组进行排序，则结果是不明确的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#sort(char[])"><CODE>sort(char[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(byte[], byte)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(byte[]&nbsp;a,
                               byte&nbsp;key)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定的 byte 型数组，以获得指定的值。<strong>必须</strong>在进行此调用之前对数组进行排序（通过上面的 <tt>sort</tt> 方法）。如果没有对数组进行排序，则结果是不明确的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#sort(byte[])"><CODE>sort(byte[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(double[], double)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(double[]&nbsp;a,
                               double&nbsp;key)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定的 double 型数组，以获得指定的值。<strong>必须</strong>在进行此调用之前对数组进行排序（通过上面的 <tt>sort</tt> 方法）。如果没有对数组进行排序，则结果是不明确的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。此方法认为所有 NaN 值都是等效且相等的。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#sort(double[])"><CODE>sort(double[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(float[], float)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(float[]&nbsp;a,
                               float&nbsp;key)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定的 float 型数组，以获得指定的值。<strong>必须</strong>在进行此调用之前对数组进行排序（通过上面的 <tt>sort</tt> 方法）。如果没有对数组进行排序，则结果是不明确的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。此方法认为所有 NaN 值都是等效且相等的。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#sort(float[])"><CODE>sort(float[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Object[], java.lang.Object)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
                               <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;key)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据数组元素的<i>自然顺序</i> 对数组进行升序排序（通过上面的 <tt>Sort(Object[]</tt> 方法）。如果没有对数组进行排序，则结果是不明确的。（如果数组包含不可相互比较的元素（例如，字符串和整数），则<i>无法</i> 根据数组元素的自然顺序对数组进行排序，因此结果是不明确的。）如果数组包含多个等于指定对象的元素，则无法保证找到的是哪一个。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果搜索的键不能与数组的元素进行比较。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口"><CODE>Comparable</CODE></A>, 
<A HREF="../../java/util/Arrays.html#sort(java.lang.Object[])"><CODE>sort(Object[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Object,java.lang.Object,java.util.Comparator)"><!-- --></A><A NAME="binarySearch(T[], T, java.util.Comparator)"><!-- --></A><H3>
binarySearch</H3>
<PRE>
public static &lt;T&gt; int <B>binarySearch</B>(T[]&nbsp;a,
                                   T&nbsp;key,
                                   <A HREF="../../java/util/Comparator.html" title="java.util 中的接口">Comparator</A>&lt;? super T&gt;&nbsp;c)</PRE>
<DL>
<DD>使用二进制搜索算法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据指定的比较器（通过上面的 <tt>Sort(Object[]、Comparator)</tt> 方法）对数组进行升序排序。如果没有对数组进行排序，则结果是不明确的。如果数组包含多个等于指定对象的元素，则无法保证找到的是哪一个。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要搜索的数组。<DD><CODE>key</CODE> - 要搜索的值。<DD><CODE>c</CODE> - 用来对数组进行排序的比较器。<tt>null</tt> 值指示应该使用元素的<i>自然顺序</i>。
<DT><B>返回：</B><DD>搜索键的索引，如果它包含在列表中；否则返回 <tt>(-(<i>插入点</i>) - 1)</tt>。<i>插入点</i> 被定义为将键插入列表的那一点：即第一个大于此键的元素索引，如果列表中的所有元素都小于指定的键，则为 <tt>list.size()</tt>。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果数组包含使用指定的比较器不<i>可相互比较</i> 的元素，或者使用此比较器无法相互比较搜索键与数组的元素。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口"><CODE>Comparable</CODE></A>, 
<A HREF="../../java/util/Arrays.html#sort(T[], java.util.Comparator)"><CODE>sort(Object[], Comparator)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="equals(long[], long[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(long[]&nbsp;a,
                             long[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 long 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="equals(int[], int[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(int[]&nbsp;a,
                             int[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 int 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="equals(short[], short[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(short[]&nbsp;a,
                             short[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 short 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="equals(char[], char[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(char[]&nbsp;a,
                             char[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 char 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="equals(byte[], byte[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(byte[]&nbsp;a,
                             byte[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 byte 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="equals(boolean[], boolean[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(boolean[]&nbsp;a,
                             boolean[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 boolean 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="equals(double[], double[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(double[]&nbsp;a,
                             double[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 double 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

如果以下条件成立，则认为两个 double 型数组 <tt>d1</tt> 和 <tt>d2</tt> 是相等的：
 <pre>    <tt>new Double(d1).equals(new Double(d2))</tt></pre>
（与 <tt>==</tt> 操作符不同，此方法认为 <tt>NaN</tt> 等于它本身，而 0.0d 不等于 -0.0d。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Double.html#equals(java.lang.Object)"><CODE>Double.equals(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="equals(float[], float[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(float[]&nbsp;a,
                             float[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 float 型数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>

如果以下条件成立，则认为两个 float 型数组 <tt>f1</tt> 和 <tt>f2</tt> 是相等的：
<pre>    <tt>new Float(f1).equals(new Float(f2))</tt></pre>
（与 <tt>==</tt> 操作符不同，此方法认为 <tt>NaN</tt> 等于它本身，而 0.0f 不等于 -0.0f。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Float.html#equals(java.lang.Object)"><CODE>Float.equals(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object[], java.lang.Object[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
                             <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定的 Objects 数组彼此<i>相等</i>，则返回 <tt>true</tt>。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。如果 <tt>(e1==null ? e2==null : e1.equals(e2))</tt>，则认为 <tt>e1</tt> 和 <tt>e2</tt> 这两个对象是<i>相等的</i> 。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。此外，如果两个数组引用都为 <tt>null</tt>，则认为它们是相等的。<p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将测试其相等性的一个数组。<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组。
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(long[], long)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(long[]&nbsp;a,
                        long&nbsp;val)</PRE>
<DL>
<DD>将指定的 long 值分配给指定 long 型数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(long[], int, int, long)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(long[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        long&nbsp;val)</PRE>
<DL>
<DD>将指定的 long 值分配给指定 long 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(int[], int)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(int[]&nbsp;a,
                        int&nbsp;val)</PRE>
<DL>
<DD>将指定的 int 值分配给指定 int 型数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(int[], int, int, int)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(int[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        int&nbsp;val)</PRE>
<DL>
<DD>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(short[], short)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(short[]&nbsp;a,
                        short&nbsp;val)</PRE>
<DL>
<DD>将指定的 short 值分配给指定 short 型数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(short[], int, int, short)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(short[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        short&nbsp;val)</PRE>
<DL>
<DD>将指定的 short 值分配给指定 short 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(char[], char)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(char[]&nbsp;a,
                        char&nbsp;val)</PRE>
<DL>
<DD>将指定的 char 值分配给指定 char 型数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(char[], int, int, char)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(char[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        char&nbsp;val)</PRE>
<DL>
<DD>将指定的 char 值分配给指定 char 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(byte[], byte)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(byte[]&nbsp;a,
                        byte&nbsp;val)</PRE>
<DL>
<DD>将指定的 byte 值分配给指定 byte 节型数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(byte[], int, int, byte)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(byte[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        byte&nbsp;val)</PRE>
<DL>
<DD>将指定的 byte 值分配给指定 byte 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(boolean[], boolean)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(boolean[]&nbsp;a,
                        boolean&nbsp;val)</PRE>
<DL>
<DD>将指定的 boolean 值分配给指定 boolean 型数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(boolean[], int, int, boolean)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(boolean[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        boolean&nbsp;val)</PRE>
<DL>
<DD>将指定的 boolean 值分配给指定 boolean 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(double[], double)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(double[]&nbsp;a,
                        double&nbsp;val)</PRE>
<DL>
<DD>将指定的 double 值分配给指定 double 型数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(double[], int, int, double)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(double[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        double&nbsp;val)</PRE>
<DL>
<DD>将指定的 double 值分配给指定 double 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(float[], float)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(float[]&nbsp;a,
                        float&nbsp;val)</PRE>
<DL>
<DD>将指定的 float 值分配给指定 float 型数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(float[], int, int, float)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(float[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        float&nbsp;val)</PRE>
<DL>
<DD>将指定的 float 值分配给指定 float 型数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.lang.Object[], java.lang.Object)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
                        <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;val)</PRE>
<DL>
<DD>将指定的 Object 引用分配给指定 Object 数组的每个元素。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>val</CODE> - 要存储在数组所有元素中的值。</DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.lang.Object[], int, int, java.lang.Object)"><!-- --></A><H3>
fill</H3>
<PRE>
public static void <B>fill</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;val)</PRE>
<DL>
<DD>将指定的 Object 引用分配给指定 Object 数组指定范围中的每个元素。填充的范围从索引 <tt>fromIndex</tt>（包括）一直到索引 <tt>toIndex</tt>（不包括）。（如果 <tt>fromIndex==toIndex</tt>，则填充范围为空。）
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要填充的数组。<DD><CODE>fromIndex</CODE> - 要使用指定值填充的第一个元素的索引（包括）。<DD><CODE>toIndex</CODE> - 要使用指定值填充的最后一个元素的索引（不包括）。<DD><CODE>val</CODE> - 要存储在数组的所有元素中的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>fromIndex &gt; toIndex</tt>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 中的类">ArrayIndexOutOfBoundsException</A></CODE> - 如果 <tt>fromIndex &lt; 0</tt> 或 <tt>toIndex &gt; a.length</tt></DL>
</DD>
</DL>
<HR>

<A NAME="asList(java.lang.Object)"><!-- --></A><A NAME="asList(T...)"><!-- --></A><H3>
asList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 中的接口">List</A>&lt;T&gt; <B>asList</B>(T...&nbsp;a)</PRE>
<DL>
<DD>返回一个受指定数组支持的固定大小的列表。（对返回列表的更改会“直写”到数组。）此方法同 <tt>Collection.toArray</tt> 一起，充当了基于数组的 API 与基于 collection 的 API 之间的桥梁。返回的列表是可序列化的，并且实现了 <A HREF="../../java/util/RandomAccess.html" title="java.util 中的接口"><CODE>RandomAccess</CODE></A>。

<p>此方法还提供了一个创建固定长度的列表的便捷方法，该列表被初始化为包含多个元素：
 <pre>
     List<String> stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);
 </pre>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 支持列表的数组。
<DT><B>返回：</B><DD>指定数组的列表视图。<DT><B>另请参见：</B><DD><A HREF="../../java/util/Collection.html#toArray()"><CODE>Collection.toArray()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(long[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>long</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 <A HREF="../../java/util/List.html" title="java.util 中的接口"><CODE>List</CODE></A> 上调用 <A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A> 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 <A HREF="../../java/lang/Long.html" title="java.lang 中的类"><CODE>Long</CODE></A> 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要计算其哈希值的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(int[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的非 null <tt>int</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 <A HREF="../../java/util/List.html" title="java.util 中的接口"><CODE>List</CODE></A> 上调用 <A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A> 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 <A HREF="../../java/lang/Integer.html" title="java.lang 中的类"><CODE>Integer</CODE></A> 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要计算其哈希值的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(short[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>short</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可用说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 <A HREF="../../java/util/List.html" title="java.util 中的接口"><CODE>List</CODE></A> 上调用 <A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A> 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 <A HREF="../../java/lang/Short.html" title="java.lang 中的类"><CODE>Short</CODE></A> 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要计算其哈希值的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(char[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>char</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可用说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 <A HREF="../../java/util/List.html" title="java.util 中的接口"><CODE>List</CODE></A> 上调用 <A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A> 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 <A HREF="../../java/lang/Character.html" title="java.lang 中的类"><CODE>Character</CODE></A> 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要计算其哈希值的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(byte[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>byte</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可用说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 <A HREF="../../java/util/List.html" title="java.util 中的接口"><CODE>List</CODE></A> 上调用 <A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A> 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 <A HREF="../../java/lang/Byte.html" title="java.lang 中的类"><CODE>Byte</CODE></A> 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要计算其哈希值的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(boolean[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(boolean[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>boolean</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 <A HREF="../../java/util/List.html" title="java.util 中的接口"><CODE>List</CODE></A> 上调用 <A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A> 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 <A HREF="../../java/lang/Boolean.html" title="java.lang 中的类"><CODE>Boolean</CODE></A> 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要计算其哈希值的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(float[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。对于任何两个满足  <tt>Arrays.equals(a, b)</tt> 的 <tt>float</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说  <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 <A HREF="../../java/util/List.html" title="java.util 中的接口"><CODE>List</CODE></A> 上调用 <A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A> 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 <A HREF="../../java/lang/Float.html" title="java.lang 中的类"><CODE>Float</CODE></A> 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要计算其哈希值的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(double[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的 <tt>double</tt> 型数组 <tt>a</tt> 和 <tt>b</tt>，也可以说  <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值与在 <A HREF="../../java/util/List.html" title="java.util 中的接口"><CODE>List</CODE></A> 上调用 <A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A> 方法获得的值相同，该 List 包含以相同顺序表示 <tt>a</tt> 数组元素的 <A HREF="../../java/lang/Double.html" title="java.lang 中的类"><CODE>Double</CODE></A> 实例的序列。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 要计算其哈希值的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(java.lang.Object[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的内容返回哈希码。如果数组包含作为元素的其他数组，则哈希码将基于其标识，而不是基于其内容。所以，在将自身包含为一个元素的数组上，直接或间接通过一个或多个数组级别来调用此方法是可接受的。

<p>对于任何两个满足 <tt>Arrays.equals(a, b)</tt> 的数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>。

<p>此方法返回的值等于 <tt>Arrays.asList(a).hashCode()</tt> 返回的值，除非 <tt>a</tt> 为 <tt>null</tt>，在这种情况下返回 <tt>0</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将计算其基于内容的哈希码的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#deepHashCode(java.lang.Object[])"><CODE>deepHashCode(Object[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="deepHashCode(java.lang.Object[])"><!-- --></A><H3>
deepHashCode</H3>
<PRE>
public static int <B>deepHashCode</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</PRE>
<DL>
<DD>基于指定数组的“深层内容”返回哈希码。如果数组包含作为元素的其他数组，则哈希码将基于其内容，并以此类推，直至无穷。所以，在将自身包含为一个元素的数组上，直接或间接通过一个或多个数组级别来调用此方法是不可接受的。这种调用的行为是不明确的。

<p>对于任何两个满足 <tt>Arrays.deepEquals(a, b)</tt> 的数组 <tt>a</tt> 和 <tt>b</tt>，也可以说 <tt>Arrays.deepHashCode(a) == Arrays.deepHashCode(b)</tt>。

<p>对此方法返回值的计算类似于对列表上的 <A HREF="../../java/util/List.html#hashCode()"><CODE>List.hashCode()</CODE></A> 返回值的计算，该列表以相同的顺序包含与 <tt>a</tt> 数组相同的元素，但有一点不同：如果数组 <tt>a</tt> 的 <tt>e</tt> 元素本身是一个数组，则不能通过调用 <tt>e.hashCode()</tt> 计算其哈希码，但是，如果 <tt>e</tt> 是一个基本类型数组，则可以通过调用 <tt>Arrays.hashCode(e)</tt> 的适当重载来计算其哈希码，或者，如果 <tt>e</tt> 是一个引用类型数组，则可以通过递归调用 <tt>Arrays.deepHashCode(e)</tt> 来计算其哈希码。如果 <tt>a</tt> 为 <tt>null</tt>，则此方法返回 0。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 将计算其基于深层内容的哈希码的数组
<DT><B>返回：</B><DD><tt>a</tt> 数组基于深层内容的哈希码<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#hashCode(java.lang.Object[])"><CODE>hashCode(Object[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="deepEquals(java.lang.Object[], java.lang.Object[])"><!-- --></A><H3>
deepEquals</H3>
<PRE>
public static boolean <B>deepEquals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a1,
                                 <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a2)</PRE>
<DL>
<DD>如果两个指定数组彼此是<i>深层相等</i> 的，则返回 <tt>true</tt>。与 @link{#equals{Object[],Object[]) 方法不同，此方法适用于任意深度的嵌套数组。

<p>如果两个数组引用均为 <tt>null</tt>，或者它们引用了包含相同元素数量的数组，并且两个数组中的所有相应元素对都是深层相等的，则认为这两个数组引用是深层相等的。

<p>如果满足以下任意条件之一，则两个 <tt>null</tt> 元素 <tt>e1</tt> 和 <tt>e2</tt> 可能是深层相等的：
 <ul>
<li> <tt>e1</tt> 和 <tt>e2</tt> 都是对象引用类型的数组，并且 <tt>Arrays.deepEquals(e1, e2)</tt> 将返回 true。
<li> <tt>e1</tt> 和 <tt>e2</tt> 都是相同基本类型的数组，并且 <tt>Arrays.equals(e1, e2)</tt> 的适当重载将返回 true。
    <li> <tt>e1 == e2</tt>
<li> <tt>e1.equals(e2)</tt> 将返回 true。
 </ul>
注意，此定义支持任意深度的 <tt>null</tt> 元素。

<p>如果指定数组中的任意一个数组，直接或间接通过一个或多个数组级别，包含数组本身作为其元素，则此方法的行为是不明确的。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a1</CODE> - 将测试其相等性的一个数组<DD><CODE>a2</CODE> - 将测试其相等性的另一个数组
<DT><B>返回：</B><DD>如果两个数组相等，则返回 <tt>true</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#equals(java.lang.Object[], java.lang.Object[])"><CODE>equals(Object[],Object[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="toString(long[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(long)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(int[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(int)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(short[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(short)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(char[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(char)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(byte[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(byte)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(boolean[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(boolean[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(boolean)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(float[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(float)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(double[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(double)</tt> 转换为字符串。如果 <tt>a</tt> 为 <tt>null</tt>，则返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(java.lang.Object[])"><!-- --></A><H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组内容的字符串表示形式。如果数组包含作为元素的其他数组，则通过从 <tt>Object</tt> 中继承的 <A HREF="../../java/lang/Object.html#toString()"><CODE>Object.toString()</CODE></A> 方法将它们转换为字符串，这描述了它们的<i>标识</i>，而不是它们的内容。

<p>此方法返回的值等于 <tt>Arrays.asList(a).toString()</tt> 返回的值，除非 <tt>a</tt> 为 <tt>null</tt>，在这种情况下返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#deepToString(java.lang.Object[])"><CODE>deepToString(Object[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="deepToString(java.lang.Object[])"><!-- --></A><H3>
deepToString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>deepToString</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]&nbsp;a)</PRE>
<DL>
<DD>返回指定数组“深层内容”的字符串表示形式。如果数组包含作为元素的其他数组，则字符串表示形式包含其内容等。此方法是为了将多维数组转换为字符串而设计的。

<p>字符串表示形式由数组的元素列表组成，括在方括号（<tt>"[]"</tt>）中。相邻元素用字符 <tt>", "</tt>（逗号加空格）分隔。这些元素通过 <tt>String.valueOf(Object)</tt> 转换为字符串，除非它们是自身的数组。

<p>如果元素 <tt>e</tt> 是一个基本类型的数组，则通过调用 <tt>Arrays.toString(e)</tt> 的适当重载将它转换为字符串。如果元素 <tt>e</tt> 是一个引用类型的数组，则通过递归调用此方法将它转换为字符串。

<p>为了避免无限递归，如果指定数组包含本身作为其元素，或者包含通过一个或多个数组级别对其自身的间接引用，则将自引用转换为字符串 <tt>"[...]"</tt>。例如，只包含对自身进行引用的数组将呈现为 <tt>"[[...]]"</tt>。

<p>如果指定数组为 <tt>null</tt>，则此方法返回 <tt>"null"</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>a</CODE> - 返回其字符串表示形式的数组
<DT><B>返回：</B><DD><tt>a</tt> 的字符串表示形式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/util/Arrays.html#toString(java.lang.Object[])"><CODE>toString(Object[])</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Arrays.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/ArrayList.html" title="java.util 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/util/BitSet.html" title="java.util 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/Arrays.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Arrays.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/j2se/1.5.0/docs/relnotes/devdocs-vs-specs.html">Java 2 SDK SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2004 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/j2se/1.5.0/docs/relnotes/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
