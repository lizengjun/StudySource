<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_03) on Mon May 29 12:07:43 CST 2006 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
java.util.concurrent (Java 2 Platform SE 5.0)
</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="java.util.concurrent (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>软件包</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">类</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/package-summary.html"><B>上一个软件包</B></A>&nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/atomic/package-summary.html"><B>下一个软件包</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/package-summary.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
软件包 java.util.concurrent
</H2>
 在并发编程中很常用的实用工具类。
<P>
<B>请参见：</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>描述</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>接口摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue&lt;E&gt;</A></B></TD>
<TD>支持两个附加操作的 <A HREF="../../../java/util/Queue.html" title="java.util 中的接口"><CODE>Queue</CODE></A>，这两个操作是：检索元素时等待队列变为非空，以及存储元素时等待空间变得可用。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 中的接口">Callable&lt;V&gt;</A></B></TD>
<TD>返回结果并且可能抛出异常的任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent 中的接口">CompletionService&lt;V&gt;</A></B></TD>
<TD>将生产新的异步任务与使用已完成任务的结果分离开来的服务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentMap.html" title="java.util.concurrent 中的接口">ConcurrentMap&lt;K,V&gt;</A></B></TD>
<TD>提供其他原子 <tt>putIfAbsent</tt>、<tt>remove</tt>、<tt>replace</tt> 方法的 <A HREF="../../../java/util/Map.html" title="java.util 中的接口"><CODE>Map</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Delayed.html" title="java.util.concurrent 中的接口">Delayed</A></B></TD>
<TD>一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口">Executor</A></B></TD>
<TD>执行已提交的 <A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口"><CODE>Runnable</CODE></A> 任务的对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口">ExecutorService</A></B></TD>
<TD><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A> 提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口"><CODE>Future</CODE></A> 的方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口">Future&lt;V&gt;</A></B></TD>
<TD><tt>Future</tt> 表示异步计算的结果。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A></B></TD>
<TD>无法由 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor</CODE></A> 执行的任务的处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 中的接口">ScheduledExecutorService</A></B></TD>
<TD>一个 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A>，可安排在给定的延迟后运行或定期执行的命令。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledFuture.html" title="java.util.concurrent 中的接口">ScheduledFuture&lt;V&gt;</A></B></TD>
<TD>一个延迟的、结果可接受的操作，可将其取消。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A></B></TD>
<TD>根据需要创建新线程的对象。</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 中的类">AbstractExecutorService</A></B></TD>
<TD>提供 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A> 执行方法的默认实现。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 中的类">ArrayBlockingQueue&lt;E&gt;</A></B></TD>
<TD>一个由数组支持的有界<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">阻塞队列</A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 中的类">ConcurrentHashMap&lt;K,V&gt;</A></B></TD>
<TD>支持检索的完全并发和更新的所期望可调整并发的哈希表。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent 中的类">ConcurrentLinkedQueue&lt;E&gt;</A></B></TD>
<TD>一个基于链接节点的、无界的、线程安全的<A HREF="../../../java/util/Queue.html" title="java.util 中的接口">队列</A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 中的类">CopyOnWriteArrayList&lt;E&gt;</A></B></TD>
<TD><A HREF="../../../java/util/ArrayList.html" title="java.util 中的类"><CODE>ArrayList</CODE></A> 的一个线程安全的变体，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent 中的类">CopyOnWriteArraySet&lt;E&gt;</A></B></TD>
<TD>对其所有操作使用 <A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 中的类"><CODE>CopyOnWriteArrayList</CODE></A> 的 <A HREF="../../../java/util/Set.html" title="java.util 中的接口"><CODE>Set</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 中的类">CountDownLatch</A></B></TD>
<TD>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent 中的类">CyclicBarrier</A></B></TD>
<TD>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent 中的类">DelayQueue&lt;E extends Delayed&gt;</A></B></TD>
<TD><tt>Delayed</tt> 元素的一个无界<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">阻塞队列</A>，只有在延迟期满时才能从中提取元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent 中的类">Exchanger&lt;V&gt;</A></B></TD>
<TD>两个线程可以交换对象的同步点。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent 中的类">ExecutorCompletionService&lt;V&gt;</A></B></TD>
<TD>使用提供的 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A> 来执行任务的 <A HREF="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent 中的接口"><CODE>CompletionService</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类">Executors</A></B></TD>
<TD>此包中所定义的 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A>、<A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A>、<A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ScheduledExecutorService</CODE></A>、<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口"><CODE>ThreadFactory</CODE></A> 和 <A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 中的接口"><CODE>Callable</CODE></A> 类的工厂和实用方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 中的类">FutureTask&lt;V&gt;</A></B></TD>
<TD>可取消的异步计算。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 中的类">LinkedBlockingQueue&lt;E&gt;</A></B></TD>
<TD>一个基于已链接节点的、范围任意的 <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">blocking queue</A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent 中的类">PriorityBlockingQueue&lt;E&gt;</A></B></TD>
<TD>一个无界的<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">阻塞队列</A>，它使用与类 <A HREF="../../../java/util/PriorityQueue.html" title="java.util 中的类"><CODE>PriorityQueue</CODE></A> 相同的顺序规则，并且提供了阻塞检索的操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 中的类">ScheduledThreadPoolExecutor</A></B></TD>
<TD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor</CODE></A>，它可另行安排在给定的延迟后运行命令，或者定期执行命令。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 中的类">Semaphore</A></B></TD>
<TD>一个计数信号量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 中的类">SynchronousQueue&lt;E&gt;</A></B></TD>
<TD>一种<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">阻塞队列</A>，其中每个 <tt>put</tt> 必须等待一个 <tt>take</tt>，反之亦然。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 中的类">ThreadPoolExecutor</A></B></TD>
<TD>一个 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A>，它使用可能的几个池线程之一执行每个提交的任务，通常使用 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类"><CODE>Executors</CODE></A> 工厂方法配置。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.AbortPolicy</A></B></TD>
<TD>用于被拒绝任务的处理程序，它将抛出 <tt>RejectedExecutionException</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.CallerRunsPolicy</A></B></TD>
<TD>用于被拒绝任务的处理程序，它直接在 <tt>execute</tt> 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.DiscardOldestPolicy</A></B></TD>
<TD>用于被拒绝任务的处理程序，它放弃最旧的未处理请求，然后重试 <tt>execute</tt>；如果执行程序已关闭，则会丢弃该任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.DiscardPolicy</A></B></TD>
<TD>用于被拒绝任务的处理程序，默认情况下它将放弃被拒绝的任务。</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>枚举摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A></B></TD>
<TD><tt>TimeUnit</tt> 表示给定单元粒度的时间段，它提供在这些单元中进行跨单元转换和执行计时及延迟操作的实用工具方法。</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>异常摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent 中的类">BrokenBarrierException</A></B></TD>
<TD>当某个线程试图等待处于断开状态的 barrier 时，或者 barrier 进入断开状态而线程处于等待状态时，抛出该异常。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CancellationException.html" title="java.util.concurrent 中的类">CancellationException</A></B></TD>
<TD>如果某项值生成任务（如 <A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 中的类"><CODE>FutureTask</CODE></A>）的结果因为任务被取消而无法检索到，则抛出该异常。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutionException.html" title="java.util.concurrent 中的类">ExecutionException</A></B></TD>
<TD>当试图检索已通过抛出异常而中止的任务的结果时，抛出此异常。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 中的类">RejectedExecutionException</A></B></TD>
<TD>当无法执行某个任务时,由 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A> 抛出的异常。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/TimeoutException.html" title="java.util.concurrent 中的类">TimeoutException</A></B></TD>
<TD>阻塞操作超时时，抛出该异常。</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
软件包 java.util.concurrent 的描述
</H2>

<P>
<p> 在并发编程中很常用的实用工具类。此包包括了几个小的、已标准化的可扩展框架，以及一些提供有用功能的类，没有这些类，这些功能会很难实现或实现起来冗长乏味。下面简要描述主要的组件。另请参阅 <tt>locks</tt> 和 <tt>atomic</tt> 包。

<h2>执行程序</h2>

<b>接口。</b><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A> 是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。根据所使用的具体 Executor 类的不同，可能在新创建的线程中，现有的任务执行线程中，或者调用 <tt>execute()</tt> 的线程中执行任务，并且可能顺序或并发执行。<A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A> 提供了多个完整的异步任务执行框架。ExecutorService 管理任务的排队和安排，并允许受控制的关闭。<A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ScheduledExecutorService</CODE></A> 子接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 <A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 中的接口"><CODE>Callable</CODE></A> 表示的任何函数，结果类似于 <A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口"><CODE>Runnable</CODE></A>。<A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口"><CODE>Future</CODE></A> 返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。

<p>

<b>实现。</b>类 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor</CODE></A> 和 <A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 中的类"><CODE>ScheduledThreadPoolExecutor</CODE></A> 提供可调的、灵活的线程池。<A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类"><CODE>Executors</CODE></A> 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。其他基于 Executor 的实用工具包括具体类 <A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 中的类"><CODE>FutureTask</CODE></A>，它提供 Future 的常见可扩展实现，以及 <A HREF="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent 中的类"><CODE>ExecutorCompletionService</CODE></A>，它有助于协调对异步任务组的处理。

<h2>队列</h2>

java.util.concurrent <A HREF="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent 中的类"><CODE>ConcurrentLinkedQueue</CODE></A> 类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。java.util.concurrent 中的五个实现都支持扩展的 <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口"><CODE>BlockingQueue</CODE></A> 接口，该接口定义了 put 和 take 的阻塞版本：<A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>LinkedBlockingQueue</CODE></A>、<A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>ArrayBlockingQueue</CODE></A>、<A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 中的类"><CODE>SynchronousQueue</CODE></A>、<A HREF="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>PriorityBlockingQueue</CODE></A> 和 <A HREF="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent 中的类"><CODE>DelayQueue</CODE></A>。这些不同的类覆盖了生产者-使用者、消息传递、并行任务执行和相关并发设计的大多数常见使用的上下文。


<h2>计时</h2>

<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举"><CODE>TimeUnit</CODE></A> 类为指定和控制基于超时的操作提供了多重粒度（包括纳秒级）。该包中的大多数类除了包含不确定的等待之外，还包含基于超时的操作。在使用超时的所有情况中，超时指定了在表明已超时前该方法应该等待的最少时间。在超时发生后，实现会&ldquo;尽力&rdquo;检测超时。但是，在检测超时与超时之后再次实际执行线程之间可能要经过不确定的时间。

<h2>同步器</h2>

四个类可协助实现常见的专用同步语句。<A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 中的类"><CODE>Semaphore</CODE></A> 是一个经典的并发工具。<A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 中的类"><CODE>CountDownLatch</CODE></A> 是一个极其简单但又极其常用的实用工具，用于在保持给定数目的信号、事件或条件前阻塞执行。<A HREF="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent 中的类"><CODE>CyclicBarrier</CODE></A> 是一个可重置的多路同步点，在某些并行编程风格中很有用。<A HREF="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent 中的类"><CODE>Exchanger</CODE></A> 允许两个线程在集合点交换对象，它在多流水线设计中是有用的。

<h2>并发 Collection</h2>

除队列外，此包还提供了几个设计用于多线程上下文中的 Collection 实现：<A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 中的类"><CODE>ConcurrentHashMap</CODE></A>、<A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 中的类"><CODE>CopyOnWriteArrayList</CODE></A> 和 <A HREF="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent 中的类"><CODE>CopyOnWriteArraySet</CODE></A>。

<p>此包中与某些类一起使用的&ldquo;Concurrent&rdquo前缀;是一种简写，表明与类似的&ldquo;同步&rdquo;类有所不同。例如，<tt>java.util.Hashtable</tt> 和 <tt>Collections.synchronizedMap(new HashMap())</tt> 是同步的，但 <A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 中的类"><CODE>ConcurrentHashMap</CODE></A> 则是&ldquo;并发的&rdquo;。并发集合是线程安全的，但是不受单个排他锁定的管理。在 ConcurrentHashMap 这一特定情况下，它可以安全地允许进行任意数目的并发读取，以及数目可调的并发写入。需要通过单个锁定阻止对集合的所有访问时，&ldquo;同步&rdquo;类是很有用的，其代价是较差的可伸缩性。在期望多个线程访问公共集合的其他情况中，通常&ldquo;并发&rdquo;版本要更好一些。当集合是未共享的，或者仅保持其他锁定时集合是可访问的情况下，非同步集合则要更好一些。

<p> 大多数并发 Collection 实现（包括大多数 Queue）与常规的 java.util 约定也不同，因为它们的迭代器提供了<em>弱一致的</em>，而不是快速失败的遍历。弱一致的迭代器是线程安全的，但是在迭代时没有必要冻结集合，所以它不一定反映自迭代器创建以来的所有更新。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>软件包</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">类</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/package-summary.html"><B>上一个软件包</B></A>&nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/atomic/package-summary.html"><B>下一个软件包</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/package-summary.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><br>有关更多的 API 参考资料和开发人员文档，请参阅 <a href="http://java.sun.com/j2se/1.5.0/docs/relnotes/devdocs-vs-specs.html">Java 2 SDK SE 开发人员文档</a>。该文档包含更详细的、面向开发人员的描述，以及总体概述、术语定义、使用技巧和工作代码示例。 <p>版权所有 2004 Sun Microsystems, Inc. 保留所有权利。 请遵守<a href="http://java.sun.com/j2se/1.5.0/docs/relnotes/license.html">许可证条款</a>。另请参阅<a href="http://java.sun.com/docs/redist.html">文档重新分发政策</a>。</font>
</BODY>
</HTML>
